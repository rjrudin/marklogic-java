buildscript {
    repositories {
        mavenCentral()
        maven {url "http://developer.marklogic.com/maven2/"}
        maven {url "http://rjrudin.github.io/marklogic-java/releases"}
        maven {url "../../gh-pages-marklogic-java/releases"}
    }

    dependencies {  classpath "com.marklogic:ml-gradle:2.0-alpha-2" }
}

apply plugin: 'ml-gradle'

//
// To use ml-gradle, you only need what is above this line. Everything below this line is optional and is intended to
// show different features provided by ml-gradle.
//

// For generating IDE project files you might consider leveraging the Eclipse or IntelliJ IDEA plugin.
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'

/*
 * This lists the repositories for finding project dependencies (which differ from buildscript dependencies - buildscript
 * dependencies are not included in project artifacts that are built). These repositories are needed to satisfy the
 * dependencies expressed below.
 */
repositories {
    mavenCentral()
    maven {url "file:../../gh-pages-marklogic-java/releases"}
    maven {url "http://developer.marklogic.com/maven2/"}
    maven {url "http://rjrudin.github.io/marklogic-java/releases"}
}

/*
 * This expresses dependencies on the ml-java and ml-junit libraries. The former is typically used for application
 * code, and the latter supports writing JUnit-based tests. A dependency exists on RestAssured to show an option for
 * using that library in tests that must invoke MarkLogic HTTP endpoints.
 */
dependencies {
    compile "com.marklogic:ml-javaclient-util:2.0.1"
    testCompile "com.marklogic:ml-junit:2.0.1"
    testCompile "com.jayway.restassured:rest-assured:2.3.1"
}

/*
 * Example of a custom command and how it's added to the AppDeployer. This could also be defined in the Gradle buildSrc
 * directory (that's more likely the better option for keeping your build.gradle file slim)
 */
ext {
    mlAppDeployer.commands.add(new MergeContentDatabaseCommand())
}

import com.marklogic.appdeployer.command.*

class MergeContentDatabaseCommand extends AbstractCommand {

    public Integer getExecuteSortOrder() {
        return 1000;
    }
    
    public void execute(CommandContext context) {
        def contentDatabaseName = context.getAppConfig().getContentDatabaseName()
        println "Merging content database"
        context.getManageClient().postJson("/manage/v2/databases/" + contentDatabaseName, '{"operation":"merge-database"}')
    }
}

/*
 * Example of doing a database merge, but not as part of the deployment process.
 */
task mergeContentDatabase(type: com.marklogic.gradle.task.MarkLogicTask) {
    doLast {
        getManageClient().postJson("/manage/v2/databases/" + getAppConfig().getContentDatabaseName(), '{"operation":"merge-database"}')
    }
}